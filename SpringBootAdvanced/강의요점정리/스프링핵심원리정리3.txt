1. 리플렉션
지금까지 프록시를 사용해서 기존 코드를 변경하지 않고, 로그 추적기라는 부가기능을 적용할 수 있었다. 
그런데 문제는 대상 클래스 수만큼 로그 추적을 위한 프록시 클래스를 만들어야 한다는 점이다. 로그 추적을 위한 프록시 클래스들의 소스코드는 거의 같은 모양을 하고 있다.

자바가 기본으로 제공하는 JDK 동적 프록시 기술이나 CGLIB 같은 프록시 생성 오픈 기술을 활용하면 프록시 객체를 동적으로 만들어낼수 있다.
쉽게 이야기해서 프록시 클래스를 지금처럼 계속 만들지 않아도 된다는 것이다. 프록시를 적용할 코드를 하나만 만들어두고 동적 프록시 기술을 사용해서 프록시 객체를 찍어내면된다.

JDK 동적 프록시를 이해하기 위해서는 먼저 자바의 리플랙션 기술을 이해해야 한다. 
리플랙션 기술을 사용하면 클래스나 메서드의 메타정보를 동적으로 획득하고, 코드도 동적으로 호출할 수 있다.
여기서는 JDK 동적 프록시를 이해하기 위한 최소한의 리플랙션 기술을 알아보자.

2. 리플랙션 코드가 필요한 예시
@Slf4j
public class ReflectionTest {

    @Test
    void reflection(){
        Hello target = new Hello();

        // 공통 로직1 시작
        log.info("start");
        String result1 = target.callA(); // 호출하는 메서드가 다름
        log.info("result={}", result1);
        // 공통 로직1 시작

        // 공통 로직2 시작
        log.info("start");
        String result2 = target.callB(); // 호출하는 메서드가 다름
        log.info("result={}", result2);
        // 공통 로직2 시작
    }

    @Slf4j
    static class Hello{
        public String callA(){
            log.info("callA");
            return "A";
        }
        public String callB(){
            log.info("callB");
            return "B";
        }
    }
}
- 공통 로직1과 공통로직2는 호출하는 메서드만 다르고 전체코드 흐름이 완전히 같다.
	- 먼저 start로그를 출력한다.
	- 어떤 메서드를 호출한다.
	- 메서드의 호출 결과를 로그로 출력한다.
- 여기서 공통로직 1과 공통 로직2를 하나의 메서드로 뽑아서 합칠 수 있을까? 중간에 호출하는 메서드가 다르기 때문에 생각보다 쉽지 않다.

이럴때 사용하는 기술이 바로 리플랙션이다. 리플렉션은 클래스나 메서드의 메타정보를 사용해서 동적으로 호출하는 메서드를 변경할 수 있다.

* 참고 *
람다를 사용해서 공통화 하는 것도 가능하다.

    @Test
    void reflection2() throws Exception {
        // 클래스 메타정보를 획득한다.
        Class classHello = Class.forName("hello.proxy.jdkdynamic.ReflectionTest$Hello");

        Hello target = new Hello();

        // callA 메서드 정보
        // 기존의 callA() callB() 메서드를 직접 호출하는 부분이 Method로 대체되었다.
        Method methodCallA = classHello.getMethod("callA");
        dynamicCall(methodCallA, target);


        // callB 메서드 정보
        Method methodCallB = classHello.getMethod("callB");
        dynamicCall(methodCallB, target);
    }

    /**
     * 공통로직1, 공통 로직 2를 한번에 처리할 수 있는 통합된 공통 처리 로직이다.
     * */
    private void dynamicCall(Method method, Object target) throws Exception{
        log.info("start");
        // 실제 실행할 인스턴스 정보가 넘어온다. 타입이 Object 라는 것은 어떠한 인스턴스도 받을수 있다는 뜻이다.
        Object result = method.invoke(target);
        log.info("result={}", result);
    }

3. 리플렉션 주의사항
리플랙션을 사용하면 클래스와 메타정보를 사용해서 애플리케이션을 동적으로 유연하게 만들 수 있다. 
하지만 리플렉션 기술은 런타임에 동작하기 때문에, 컴파일 시점에 오류를 잡을 수 없다.
예를 들어서 지금까지 살펴본 코드에서 getMethod("callA")안에 들어가는 문자를 실수로 getMethod("callㅋ")로 작성해도 컴파일 오류가 나지 않는다.
대신 해당 코드를 직접 실행하는 시점에 발생하는 오류인 런타임 오류가 발생한다.
가장 좋은 오류는 개발자가 즉시 확인할 수 있는 컴파일 오류이고, 가장 무서운 오류는 사용자가 직접 실행할 때 발생하는 런타임 오류다.

따라서 리플랙션은 일반적으로 사용하면 안된다. 
리플랙션은 프레임워크 개발이나 또는 매우 일반적인 공통 처리가 필요할 때 부분적으로 주의해서 사용해야 한다.

4. JDK 동적 프록시 
지금까지 프록시를 적용하기 위해 적용 대상의 숫자 만큼 많은 프록시 클래스를 만들었다.
즉 프록시의 로직은 같은데, 적용 대상만 차이가 있는것이다.
이문제를 해결하는 것이 바로 동적 프록시 기술이다.
동적 프록시 기술을 사용하면 개발자가 직접 프록시 클래스를 만들지 않아도 된다. 이름 그대로 프록시 객체를 동적으로 런타임에 개발자가 대신 만들어준다.
그리고 동적 프록시에 원하는 실행 로직을 지정할 수 있다.
* 주의 *
JDK 동적 프록시는 인터페이스를 기반으로 프록시를 동적으로 만들어준다. 따라서 인터페이스가 필수이다.

5. JDK 동적 프록시 예시 실행 순서
1. 클라이언트는 JDK 동적프록시의 call()을 실행한다.
2. JDK 동적 프록시는 InvocationHandler.invoke()를 호출한다. 
TimeInvocationHandler가 구현체로 있으므로 TimeInvocationHanler.invoke()가 호출된다.
3. TimeInvocationHandler가 내부 로직을 수정하고, method.invoke(target, args)를 호출해서 target인 실제 객체 AImpl를 호출한다.
4. AImpl 인스턴스의 call()이 호출된다.
5. AImpl 인스턴스의 call()의 실행이 끝나면 TimeInvocationHandler로 응답이 돌아온다. 시간 로그를 출력하고 결과를 반환한다.

JDK 동적 프록시 기술 덕분에 적용 대상 만큼 프록시 객체를 만들지 않아도 된다. 그리고 같은 부가 기능 로직을 한번만 개발해서 공통으로 적용할 수 있다.
만약 적용 대상이 100개여도 동적 프록시를 통해서 생성하고, 각각 필요한 InvocaqtionHandler만 만들어서 넣어주면 된다. 
부가기능 로직도 하나의 클래스에 모아서 단일 책임 원칙도(SRP)도 지킬 수 있게 되었다.

6. JDK 동적 프록시 - 메서드 이름 필더 기능 추가
if(!PatternMatchUtils.simpleMatch(patterns, methodName)){
	return method.invoke(target,args);
}

7. JDK 동적 프록시 - 한계
JDK 동적 프록시는 인터페이스가 필수이다.
그렇다면 V2 애플리케이션 처럼 인터페이스 없이 클래스만 있는 경우에는 어떻게 동적 프록시를 적용할 수 있을까? - CGLIB(거의 사용 안함), ProxyFactory

8. CGLIB : Code Generator Library
- CGLIB는 바이트코드를 조작해서 동적으로 클래스를 생성하는 기술을 제공하는 라이브러리이다.
- CGLIB를 사용하는 인터페이스가 없어도 구체 클래스만 가지고 동적 프록시를 만들어낼 수 있다.
- CGLIB는 원래는 외부 라이브러리인데, 스프링 프레임워크가 스프링 내부 소스 코드에 포함했다. 
따라서 스프링을 사용한다면 별도의 외부 라이브러리를 추가하지 않아도 사용할 수 있다.
- JDK 동적 프록시에서 실행 로직을 위해 InvocationHandler를 제공했듯이, CGLIB는 MethodInterceptor를 제공한다.

9. CGLIB 제약
- 클래스 기반 프록시는 상속을 사용하기 때문에 몇가지 제약이있다.
	- 부모클래스의 생성자를 체크해야한다. - CGLIB는 자식클래스를 동적으로 생성하기에 기본생성자가 필요하다.
	- 클래스와 메소드에 final을 붙일 수 없다.
	
====================================================================================================
10. 프록시 팩토리
앞서 마지막에 설명했던 동적 프록시를 사용할 때 문제점
- 인터페이스가 있는 경우에는 JDK 동적 프록시를 사용하고, 그렇지 않은 경우에는 CGLIB를 적용하려면 어떻게 해야할까?
- 두 기술을 함께 사용할 때 부가기능을 제공하기 위해 JDK 동적 프록시가 제공하는 InvocationHandler와 CGLIB가 제공하는 MethodInterceptor를 각각
중복으로 만들어서 관리해야 할까?
- 특정 조건이 맞을때 프록시 로직을 적용하는 기능도 공통으로 제공되었으면? - 프록시 팩토리

- 스프링은 동적 프록시를 통합해서 편리하게 만들어주는 프록시 팩토리(proxyFactory)라는 기능을 제공한다.
- 이전에는 상황에 따라서 JDK 동적 프록시를 사용하거나 CGLIB를 사용해야 했다면, 이젠 이 프록시 팩토리를 하나로 편리하게 동적 프록시를 생성할 수 있다.
- 프록시 팩토리는 인터페이스가 있으면 JDK 동적 프록시를 사용하고, 구체클레스만 있다면 CGLIB를 사용한다. 그리고 이 설정을 변경할 수도 있다.

두 기술을 함께 사용할 때 부가 기능을 적용하기 위해 JDK 동적 프록시가 제공하는 InvocationHandler와 CGLIB가 제공하는 MethodInterceptor를
각각 중복으로 따로 만들어야할까?
- 스프링은 이 문제를 해결하기 위해 부가기능을 적용할 때 Advice라는 새로운 개념을 도입했다. 개발자는 InvocationHandler와 MethodInterceptor를 
신경쓰지 않고, Advice만 만들면 된다.
- 결과적으로 InvocationHandler와 MethodInterceptor는 Advice를 호출하게 된다.
- 프록시 팩토리를 사용하면 Advice를 호출하는 전용 InvocationHandler와 MethodInterceptor를 내부에서 사용한다.

특정 조건이 맞을 때 프록시 로직을 적용하는 기능도 공통으로 제공되었으면?
앞서 특정 메서드 이름의 조건에 맞을 때만 프록시 부가 기능이 적용되는 코드를 직접 만들었다. 스프링은 PointCut이라는 개념을 도입해서 이 문제를 일관성있게 해결한다.

11. 프록시 팩토리의 기술 선택 방법
- 대상에 인터페이스가 있으면 : JDK 동적 프록시, 인터페이스 기반 프록시
- 대상에 인터페이스가 없으면 : CGLIB, 구체 클레스 기반 프록시
- proxyTargetClass=true : CGLIB, 구체클래스 기반 프록시, 인터페이스 여부와 상관 없음

* 참고 *
스프링 부트는 AOP를 적용할 때 기본적으로 proxyTargetClass = true로 설정해서 사용한다.
따라서 인터페이스가 있어도 항상 CGLIB를 사용해서 구체 클래스를 기반으로 프록시를 생성한다.

12. 포인트컷, 어드바이스, 어드바이저 정의
- 포인트컷(PointCut) : 어디에 부가 기능을 적용할지, 어디에 부가 기능을 적용하지 않을지 판단하는 필터링 로직이다. 주로 클래스와 메서드 이름으로 필터링한다.
이름 그대로 어떤 포인트(Point)에 기능을 적용할지 하지 않을지 잘라서(cut) 구분하는 것이다.
- 어드바이스(Advice) : 이전에 본 것처럼 프록시가 호출하는 부가 기능이다. 단순하게 프록시 로직이라 생각하면된다.
- 어드바이저(Advisor) : 단순하게 하나의 포인트 컷과 하나의 어드바이스를 가지고 있는 것이다. 쉽게 이야기해서 '포인트 컷1 + 어드바이스1' 이다.

"정리하면"
부가기능 로직을 적용해야하는데, 포인트컷으로 어디에? 적용할지 선택하고, 어드바이스로 어떤 로직을 적용할지 선택하는 것이다. 
그리고 어디에 어떤 로직을 모두 알고 있는것이 어드바이저이다.

"역할과 책임"
이렇게 구분한 것은 역할과 책임을 명확하게 분리한 것이다.
- 포인트컷은 대상 여부를 확인하는 필터 역할만 담당한다.
- 어드바이스는 깔끔하게 부가 기능 로직만 담당한다.
- 둘을 합치면 어드바이저가 된다. 스프링의 어드바이저는 하나의 포인트컷 + 하나의 어드바이스로 구성된다.

13. 포인트 컷 직접 만들기
- 포인트 컷은 크게 ClassFilter와 MethodMatcher둘로 이루어 진다.
- 이름 그대로 하나는 클래스가 맞는지, 하나는 메서드가 맞는지 확인할 때 사용한다.
- 둘다 true로 반환해야 어드바이스를 적용할 수 있다.

14. 스프링이 제공하는 포인트 컷
대표적인 것 모음
- NamedMatchMethodPointcut : 메서드 이름을 기반으로 매칭한다. 내부에서는 PatternMatchUtils를 사용한다.
- JdkRegexMethodPointCut : JDK 정규 표현식을 기반으로 포인트컷을 매칭한다.
- TruePointCut : 항상 참을 반환
- AnnotationMatchingPointcut : 어노테이션을 기반으로 매칭한다.
- AspoectExpressionPointcut : aspectJ 표현식으로 매칭한다.

15. 여러 프록시의 문제
이 방법이 잘못된 것은 아니지만, 프록시를 2번 생성해야 한다는 문제가 있다. 만약 적용해야 하는 어드바이저가 10개라면 10개의 프록시를 생성해야 한다.

해결 방법 - 아래의 예제
 @Test
    @DisplayName("하나의 프록시, 여러 어드바이저")
    void multiAdvisorTest2(){
        /**
         * client -> proxy -> advisor2 -> advisor1 -> target
         * */
        DefaultPointcutAdvisor advisor1 = new DefaultPointcutAdvisor(Pointcut.TRUE, new Advice1());
        DefaultPointcutAdvisor advisor2 = new DefaultPointcutAdvisor(Pointcut.TRUE, new Advice2());

        ServiceInterface target = new ServiceImpl();
        ProxyFactory proxyFactory = new ProxyFactory(target);

        proxyFactory.addAdvisor(advisor2);
        proxyFactory.addAdvisor(advisor1);
        ServiceInterface proxy = (ServiceInterface) proxyFactory.getProxy();

        proxy.save();
    }

- 결과적으로 여러 프록시를 사용할 때와 비교해서 결과는 같고, 성능은 더 좋다.

"중요"
사실 이번장을 이렇게 풀어서 설명한 이유가 있다. 스프링 AOP를 처음 공부하거나 사용하면, AOP 적용수 만큼 프록시가 생성된다고 착각하게된다.
스프링은 AOP를 적용할 때, 최적화를 진행해서 지금처럼 프록시는 하나만 만들고, 하나의 프록시에 여러 어드바이저를 적용한다.
정리하면 하나의 target에 여러 AOP가 동시에 적용되어도, 스프링 AOP는 target마다 하나의 프록시만 생성한다.

16. 포인트 컷의 남은 문제
"너무 많은 설정"
ProxyFactoryConfigV1, ProxyFactoryConfigV2와 같은 설정 파일이 지나치게 많다는 점이다.
예를들어서 스프링 빈이 100개가 있다면 여기에 프록시를 통해 부가기능을 적용하려면 100개의 동적 프록시 생성 코드를 만들어야한다.
무수히 많은 설정 파일 때문에 설정 지옥을 경험하게 될것이다.
최근에는 스프링 빈을 등록하기 귀찮아서 컴포넌트 스캔까지 사용하는데, 이렇게 직접 등록하는 것도 모자라서, 프록시를 적용하는 코드까지 빈 생성 코드에 넣어야한다.

"컴포넌트 스캔"
애플리케이션 V3처럼 컴포넌트 스캔을 사용하는 경우 지금까지 학습한 방법으로는 프록시 적용이 불가하다.
왜냐하면 실제 객체를 컴포넌트 스캔으로 스프링 컨테이너에 스프링 빈으로 등록을 다 등록을 해버린 상태이기 떄문이다.
지금까지 학습한 프록시를 적용하려면, 실제 객체를 스프링 컨테이너 빈에 등록하는 것이 아니라. ProxyFactoryConfigV1에서 한것 처럼, 부가 기능이 있는
프록시를 실제 객체 대신 스프링 컨테이너 빈으로 등록해야 한다.

해결 방법 - 빈 후기처리

17. 빈 후기처리 
@Bean이나 컴포넌트 스캔으로 스프링 빈을 등록하면, 스프링은 대상 객체를 생성하고 스프링 컨테이너 내부의 빈 저장소에 등록한다.
그리고 이후에는 스프링 컨테이너를 통해 등록한 스프링 빈을 조회해서 사용한다.

"빈 후기처리 - BeanPostProcessor"
스프링 빈 저장소에 등록할 목적으로 생성한 객체를 빈 저장소에 등록하기 직전에 조작하고 싶다면 빈 후기처리기를 사욯하면된다.
빈 포스트 프로세서(BeanPostProcessor)는 번역하면 빈 후처리기인데, 이름 그대로 빈을 생성한 후에 무언가를 처리하는 용도로 사용한다.

"빈 후처리 기능"
빈 후처리기의 기능은 막강하다. 객체를 조작할 수도 있고, 완전히 다른 객체로 바꿔치기 하는 것도 가능하다.

"빈 후처리기의 빈 등록 과정"
1. 생성 : 스프링 빈 대상이 되는 객체를 생성한다.
2. 전달 : 생성된 객체를 빈 저장소에 등록하기 직전에 빈 후처리기에 전달한다.
3. 후 처리 작업 : 빈 후처리기는 전달된 스프링 빈 객체를 조작하거나 다른 객체로 바꿔치기 할 수 있다.
4. 등록 : 빈 후처리기는 빈을 반환한다. 전달 된 빈을 그대로 반환하면 해당 빈이 등록되고, 바꿔치기 하면 다른 객체가 빈 저장소에 등록된다.

18. BeanPostProcessor
- 빈 후처리기를 사용하려면 BeanPostProcessor 인터페이스를 구현하고, 스프링 빈으로 등록하면 된다.
- postProcessorBeforeInitialization : 객체 생성 이후에 @PostConstruct같은 초기화가 발생하기 전에 호출되는 포스트 프로세서이다.
- postProcessAfterInitialization : 객체 생성 이후에 @PostConstruct 같은 초기화가 발생한 다음에 호출되는 포스트 프로세서이다.

"정리"
빈 후처리기는 빈을 조작하고 변경할 수 있는 후킹 포인트이다.
이것은 빈 객체를 조작하거나 다른 객체로 바꾸어 버릴 수 있을 정도로 막강하다.
여기서 조작이라는 것은 해당 객체의 특정 메서드를 호출하는 것을 말한다.
일반적으로 스프링 컨테이너가 등록하는, 특히 컴포넌트 스캔의 대상이 되는 빈들은 중간에 조작할 방법이 없는데, 
빈 후처리기를 사용하면 개발자가 등록하는 모든 빈을 중간에 조작할 수 있다.
이 말은 '빈 객체를 프록시로 교체'하는 것도 가능하다.

* 참고 * - @PostConstruct의 비밀
@PostConstruct는 스프링 빈 생성 이후에 빈을 초기화 하는 역할을 한다. 그런데 생각해보면 빈의 초기화라는 것이 단순히 @PostConstruct 애노테이션이 붙은 초기화
메서드를 한번 호출만 하면된다. 쉽게 이야기해서 생성된 빈을 한번 조작하는 것이다. 따라서 빈을 조작하는 행위를 하는 적절한 빈 후처리기가 있으면 될 것 같다.
스프링은 CommonAnnotaionBeanPostProcessor라는 빈 후처리기를 자동으로 등록하는데, 여기에서 @PostConstruct어노테이션이 붙은 메서드를 호출한다.
따라서 스프링 스스로도 스프링 내부의 기능을 확장하기 위해 빈 후처리기를 사용한다.

19. 빈 후처리기 적용
빈 후처리기를 사용해서 실제 객체 대신 프록시를 스프링 빈으로 등록해보자.
이렇게 하면 수동으로 등록하는 빈은 물론이고, 컴포넌트 스캔을 사용하는 빈까지 모두 프록시를 적용할 수 있다.
더 나아가서 설정 파일에 있는 수많은 프록시 생성 코드도 한번에 제거할 수 있다.

"중요"
프록시의 적용 대상 여부를 여기서는 간단한 패키지를 기준으로 설정했다. 그런데 잘 생각해보면 포인트컷으로 사용하면 더 깔끔하다.
포인트컷은 이미 클래스, 메서드 단위의 필터 기능을 가지고 있기 때문에, 프록시 적용 대상 여부를 정밀하게 설정할 수 있다.
참고로 어드바이저는 포인트컷을 가지고 있다. 따라서 어드바이저를 통해 포인트컷을 확인할 수 있다. 
뒤에서 학습하겠지만 스프링 AOP는 포인트컷을 사용해서 프록시 적용 대상 여부를 체크한다.

1. 프록시 적용 대상 여부를 체크해서 꼭 필요한 곳에만 프록시를 적용한다.(빈 후처리기 - 자동 프록시 생성)
2. 프록시의 어떤 메서드가 호출되었을 때 어드바이스를 적용할지 판단한다. (프록시 내부)

20. 스프링이 제공하는 빈 후처리기
implementation 'org.springframework.boot:spring-boot-starter-aop'

"자동 프록시 생성기 AutoProxyCreator"
- 앞서 이야기한 스프링 부트 자동 설정으로 AnnotaionAwareAspectJAutoProxyCreator라는 빈 후처리기가 스프링 빈 안에 자동으로 등록된다.
- 이름 그대로 자동으로 프록시를 생성해주는 빈 후처리기이다.
- 이 빈 후처리기는 스프링 빈으로 등록된 Advisor들을 자동으로 찾아서 프록시가 필요한 곳에 자동으로 프록시를 적용해준다.
- Advisor안에는 PointCut과 Advice가 이미 모두 포함되어 있다. 따라서 Advisor만 알고 있으면 그 안에 있는 Pointcut으로 어떤
스프링 빈에 프록시를 적용해야 할지 알 수 있다. 그리고 Advice로 부가 기능을 적용하면된다.

21. 자동 프록시 생성기 작동과정
1. 생성 : 스프링이 스프링 빈 대상이 되는 객체를 생성한다. @Bean, 컴포넌트 스캔 포함
2. 전달 : 생성된 객체를 빈 저장소에 등록하기 직전에 빈 후처리기에 전달한다.
3. 모든 Advisor 빈 주회 : 자동 프록시 생성기 - 빈 후처리기는 스프링 컨테이너에서 모든 Advisor를 조회한다.
4. 프록시 적용 대상 체크 : 앞서 조회한 Advisor에 포함되어 있는 포인트 컷을 사용해서 해당 객체가 프록시를 적용할 대상인지 아닌지 판단한다.
이때 객체의 클래스 정보는 물론이고, 해당 객체의 모든 메서드를 포인트컷에 하나하나 모두 매칭해본다. 그래서 조건이 하나라도 만족하면 프록시 적용대상이된다.
예를들어 10개의 메서드 중에 하나만 포인트컷 조건에 만족해도 프록시 적용 대상이 된다.
5. 프록시 생성 : 프록시 적용 대상이면 프록시를 생성하고 반환해서 프록시를 스프링 빈으로 등록한다. 만약 프록시 적용 대상이 아니라면
원본 객체를 반환해서 원본 객체를 스프링 빈으로 등록한다.
6. 빈등록 : 반환된 객체는 스프링 빈으로 등록한다.

22. 포인트 컷 사용 2가지
1. 프록시 적용 여부 판단 - 생성단계
	- 자동 프록시 생성기는 포인트컷을 사용해서 해당 빈이 프록시를 생성할 필요가 있는지 없는지 체크한다.
	- 클래스 + 메소드 조건을 모두 비교한다. 이떄 모든 메서드를 체크하는데, 포인트컷 조건에 하나하나 매칭해본다. 
	만약 조건에 맞는 것이 하나라도 있으면 프록시를 생성한다.
		- 예) orderControllerV1은 request(), nolog()가 있다. 여기에서 request()가 조건에 만족하므로 프록시를 생성한다.

2. 어드바이스 적용 여부 판단 - 사용 단계
	- 프록시가 호출되었을때 부가 기능인 어드바이스를 적용할지 말지 포인트컷을 보고 판단한다.
	- 앞서 설명한 예에서 orderControllerV1은 이미 프록시가 걸려있다.
	- orderControllerV1의 request()는 현재 포인트 컷 조건에 만족하므로 프록시는 어드바이스를 먼저 호출하고, target을 호출한다.
	- orderControllerV1의 nolog()는 현재 포인트 컷 조건에 만족하지 않으므로 어드바이스를 호출하지 않고 target만 호출한다.

23. AspectJExpressionPoincut
AspectJ라는 AOP에 특화된 포인트컷 표현식을 적용할 수 있다. AspectJ 포인트컷 

24. 하나의 프록시, 여러 Advisor 사용
예를들어서 어떤 스프링 빈이 advisor1, advisor2가 제공하는 포인트컷의 조건을 모두 만족하면 프록시 자동 생성기는 프록시를 몇개 생성할까?
프록시 자동 생성기는 프록시를 하나만 생성한다. 왜냐하면 프록시 팩토리가 생성하는 프록시는 내부에 여러 advisor 들을 포함할 수 있기 때문이다.

"프록시 자동 생성기 상황별 정리"
- advisor의 포인트컷만 만족 -> 프록시 1개 생성, 프록시에 advisor1만 포함
- advisor1, advisor2의 포인트 컷을 모두 만족 -> 프록시 1개 생성, 프록시에 advisor1, advisor2모두 포함

25. @Aspect 프록시 적용
스프링 어플리케이션에 프록시를 적용하려면 포인트컷과 어드바이스로 구성되어있는 어드바이저(Advisor)를 만들어서 스프링 빈으로 등록하면된다.
그러면 나머지는 앞서 배운 자동 프록시 생성기가 모두 자동으로 처리해준다. 자동 프록시 생성기는 스프링 빈으로 등록된 어드바이저들을 찾고,
스프링 빈들에 자동으로 프록시를 적용해준다.(포인트 컷에 매칭되는 경우)
스프링은 @Aspect어노테이션으로 매우 편리하게 포인트컷과 어드바이스로 구성되어있는 어드바이저 생성 기능을 지원한다.

"자동 프록시 생성기는 2가지 일을 한다"
1. @Aspect를 보고 어드바이저(Advisor)로 변환해서 저장한다.
2. 어드바이저를 기반으로 프록시를 생성한다.

26. @Aspect를 어드바이저로 변환해서 저장하는 과정
1. 실행 : 스프링 애플리케이션 로딩 시점에 자동 프록시 생성기를 호출한다.
2. 모든 @Aspect 빈 조회 : 자동 프록시 생성기는 스프링 컨테이너에 @Aspect에노테이션이 붙은 스프링 빈을 모두 조회한다.
3. 어드바이저 생성 : @Aspect 어드바이저 빌더를 통해 @Aspect 애노테이션정보를 기반으로 어드바이저를 생성한다.
4. @Aspect 기반 어드바이저 저장 : 생성한 어드바이저를 @Aspect 어드바이저 빌더 내부에 저장한다.

27. 자동 프록시 생성기의 작동 과정
1. 생성 : 스프링 빈 대상이 되는 객체를 생성한다 (@Bean, 컴포넌트 스캔 모두 포함)
2. 전달 : 생성된 객체를 빈 저장소에 등록하기 직전에 빈 후처리기에 전달한다.
3-1. Advisor 빈 조회 : 스프링 컨테이너에서 Advisor 빈을 모두 조회한다.
3-2. @Aspect Advisor 빈 조회 : @Aspect어드바이저 빌더 내부에 저장된 Advisor를 모두 조회한다.
4. 프록시 적용 대상 체크 : 3-1, 3-2에서 조회한 Advisor에 포함되어 있는 포인트컷을 사용해서 해당 객체가 프록시를 적용할 대상인지 아닌지 판단한다.
이때 객체의 프록시 정보는 물론이고 해당 객체의 모든 메서드를 포인트컷에 하나한 모두 매칭해본다. 그래서 조건이 하나라도 만족하면 프록시 적용대상이된다.
5. 프록시 생성 : 프록시 적용대상이면 프록시를 생성하고 프록시를 반환한다. 그래서 프록시를 스프링빈으로 등록한다. 만약에 프록시 적용 대상이 아니라면 원본 객체를
반환해서 원본 객체를 스프링 빈으로 등록한다.
6. 빈 등록: 반환된 객체는 스프링 빈으로 등록된다.

28. 정리
@Aspect를 사용해서 애노테이션 기반 프록시를 매우 편리하게 적용해보았다. 실무에서 프록시를 적용할 때는 대부분 이 방식을 사용한다.

지금까지 우리가 진행한 애플리케이션 전반에 로그를 남기는 기능은 특정 기능하나에 관심이 있는 기능이아니다. 애플리케이션의 여러 기능들 사이에 걸쳐서 들어가는 관심사이다.
이것을 바로 "횡단 관심사(cross-cutting concerns)"라고 한다.
이제 이 기반을 바탕으로 횡단 관심사를 전문으로 해결하는 스프링 AOP에 대해 본격적으로 알아보자.
