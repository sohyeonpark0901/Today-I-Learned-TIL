1. AOP 소개 - 핵심 기능과 부가 기능
- 핵심 기능 : 해당 객체가 제공하는 고유의 기능
- 부가기능 : 핵심 기능을 보조하기 위해 제공되는 기능. 예를들어서 로그 추적 로직, 트랜잭션 기능이 있다.
이러한 부가 기능은 단독으로 사용되지 않고, 핵심 기능과 함께 사용된다.

"여러 곳에서 공통으로 사용하는 부가 기능"
횡단 관심사(cross-cutting concerns) : 하나의 부가 기능이 여러 곳에서 동일하게 사용된다.

2. AOP 소개 - Aspect
"핵심 기능과 부가 기능을 분리"
부가기능과 부가 기능을 어디에 적용할지 선택하는 기능을 합쳐서 하나의 모듈로 만들었는데 이것이 바로 Aspect이다. 쉽게 말해서
부가기능과 해당 부가 기능을 어디에 적용할지 정의한 것이다. 예를 들어서 로그 출력 기능을 모든 컨트롤러에 적용해라 라는 것이 정의되어 있다.
그렇다 바로 우리가 이전에 알아본 @Aspect가 바로 그것이다. 그리고 스프링이 제공하는 어드바이저도 어드바이스(부가기능)과 포인트컷(적용대상)을 가지고 있어서
개념상 하나의 Aspect 이다.
Aspect는 관점이라는 뜻인데, 관점을 하나하나의 기능에서 횡단 관심사(cross-cutting concerns)관점으로 달리 보는 것이다.
이렇게 "Aspect를 사용한 프로그래밍 방식을 관점지향 프로그래밍 AOP(Aspect-Oriented Programming)이다.

"참고로 AOP는 OOP를 대체하기 위한 것이 아닌, 횡단 관심사를 깔끔하게 처리하기 어려운 OOP의 부족한 부분을 보조하는 목적으로 개발되었다."

3. AspectJ 프레임워크
AOP의 대표적인 구현으로 AspectJ 프레임워크가 있다. 물론 스프링도 AOP를 지원하지만 대부분 AspectJ문법을 차용하고, AspectJ가 제공하는 기능의 일부만 제공한다.

AspectJ 프레임워크는 스스로 다음과 같이 설명한다.
- 자바 프로그래밍 언어에 대한 완벽한 관점 지향 확장
- 횡단 관심사의 깔끔한 모듈화
	- 오류 처리 및 검사, 동기화, 성능 최적화(캐싱), 모니터링 및 로깅
	
4. AOP 적용방식
AOP를 사용하면 핵심기능과 부가 기능이 코드상 완전히 분리되어서 관리된다.
그렇다면 AOP를 사용할 때 부가 기능 로직은 어떤 방식으로 실제 로직에 추가될 수 있을까?
- 컴파일 시점 - 잘 사용하지 않음
- 클래스 로딩 시점 - 잘 사용하지 않음
- 런타임 시점(프록시)
	- 컴파일도 다 끝나고, 클래스 로더에 클래스도 다 올라가서 이미 자바가 실행되고 난 다음을 말한다.
	- 자바의 메인 메서드가 이미 실행된 다음이다.
	- 따라서 자바 언어가 제공하는 범위 안에서 부가 기능을 적용해야 한다.
	- 스프링과 같은 컨테이너의 도움을 받고 프록시와 DI, 빈 포스트 프로세서 같은 개념들을 총 동원해야 한다.
	- 이렇게 하면 최종적으로 프록시를 통해 스프링 빈에 부가 기능을 적용 할 수 있다.

런타임 시점은 실제 대상 코드는 그대로 유지된다. 대신에 프록시를 통해 부가 기능이 적용된다.
따라서 항상 프록시를 통해야 부가기능을 사용할 수 있다. 스프링은 AOP이 방식을 사용한다.

5. AOP 적용 위치
- 적용 가능 지점(조인 포인트) : 생성자, 필드 값 접근, static 메서드 접근, 메서드 실행
	- 이렇게 AOP를 적용할 수 있는 지점을 조인 포인트(Join Point)라 한다.
- AspectJ를 사용해서 컴파일 시점과 클래스 로딩 시점에 적용하는 AOP를 바이트코드를 실제 조작하기 때문에 해당 기능을 모든 지점에 다 적용할 수 있다.
- 프록시 방식을 사용하는 스프링 AOP는 메서드 실행 지점에만 AOP를 적용할 수 있다.
	- 프록시 메서드 오버라이딩 개념으로 동작한다. 따라서 생성자나 static 메서드, 필드 값 접근에는 프록시 개념이 적용될 수 없다.
	- 프록시를 사용하는 "스프링 AOP 조인 포인트는 메서드 실행으로 제한"된다.
- 프록시 방식을 사용하는 스프링 AOP는 스프링 컨테이너가 관리할 수 있는 "스프링 빈에만 AOP"를 적용할 수 있다.

6. AOP 용어 정리
- 조인 포인트(Join Point)
	- 어드바이스가 적용될 수 있는 위치, 메소드 실행, 생성자 호출, 필드 값 접근, static 메서드 접근 같은 프로그램 실행 중 지점
	- AOP를 적용할 수 있는 모든 지점이라 생각하면된다.
	- 스프링 AOP는 프록시 방식을 사용하기때문에 조인포인트는 항상 메소드 실행 지점으로 제한된다.

- 포인트컷(Pointcut)
	- 조인 포인트 중에서 어드바이스가 적용될 위치를 선별하는 기능
	- 주로 AspectJ 표현식을 사용해서 지정
	- 프록시를 사용하는 스프링 AOP는 메서드 실행 지점만 포인트컷으로 선별 가능

- 타겟(Target)
	- 어드바이스를 받는 객체, 포인트컷으로 결정

- 어드바이스(Advice)
	- 부가기능
	- Around(주변), Before, After와 같은 다양한 종류의 어드바이스가 있음

- 애스팩트(Aspect)
	- 어드바이스 + 포인트컷을 모듈화 한것
	- @Aspect를 생각하면됨
	- 여러 어드바이스와 포인트 컷이 함께 존재

- 어드바이저(Advisor)
	- 하나의 어드바이스와 하나의 포인트 컷으로 구성
	- 스프링 AOP에서만 사용되는 특별한 용어

- 위빙(weaving)
	- 포인트컷으로 결정한 타겟의 조인 포인트에 어드바이스를 적용하는 것
	- 위빙을 통해 핵심 기능 코드에 영향을 주지 않고 부가 기능을 추가 할 수 있음
	- AOP적용을 위해 애스팩트를 객체에 연결한 상태
		- 컴파일 타임
		- 로드 타임
		- 런타임, 스프링 AOP는 런타임, 프록시 방식

- AOP 프록시
	- AOP 기능 구현하기 위해 만든 프록시 객체, 스프링에서 AOP 프록시는 JDK 동적 프록시 또는 CGLIB 프록시이다.
	
7. 스프링 AOP 구현
스프링 AOP를 구현하는 일반적인 방법은 앞서 학습한 @Aspect를 사용하는 방법이다.
이번 시간에는 @Aspect를 사용해서 가장 단순한 AOP를 구현해보자. 

- @Aspect는 Aspect라는 표식이지 컴포넌트 스캔이 되는 것은 아니다. 따라서 AspectV1를 AOP로 사용하려면 스프링 빈으로 등록해야 한다.

"스프링 빈으로 Aspect 등록하는 법"
- @Bean을 사용해서 직접 등록
- @Component 컴포넌트 스캔을 사용해서 자동 등록
- @Import 주로 설정 파일을 추가할 때 사용 @Configuration

@Import는 주로 설정 파일을 추가할 때 사용하지만, 이 기능으로 스프링 빈도 등록할 수 있다. 

8. 스프링 AOP 구현 - 포인트컷 분리
@Around에 포인트컷 표현식을 직접 넣을 수 있지만, @Pointcut 어노테이션을 사용해서 별도로 분리할 수도 있다.

9. @Pointcut

@Slf4j
@Aspect
public class AspectV2 {

    //hello.aop.order 패키지와 하위 패키지 - 포인트컷컷
    @Pointcut("execution(* hello.aop.order..*(..))")
    private void allOrder(){} // pointcut 시그니처

    // 포인트컷컷
   @Around("allOrder()")
    // 어드바이스
    public Object doLog(ProceedingJoinPoint joinPoint) throws Throwable{
        log.info("[log] {}", joinPoint.getSignature()); // join point 시그니처
        return joinPoint.proceed();
    }
}
- 포인트컷 표현식을 사용한다.
- 메서드 이름과 파라미터를 합쳐서 포인트컷 시그니처(Signature)라 한다.
- 메서드 반환 타입은 void 여야 한다.
- 코드 내용은 비워든다.
- 포인트컷 시그니처는 allOrder()이다. 이름 그대로 주문과 관련된 모든 기능을 대상으로 하는 포인트컷이다.
- @Around 어드바이스에서는 포인트컷을 직접 지정해도 되지만, 포인트컷 시그니처를 사용해도 된다. 여기서는 @Around("allOrder()")를 사용한다.
- 내부에서만 접근하려면 private을 사용해도 되지만, 다른 aspect에서 참고하려면 public을 사용해야 한다.

10. 스프링 AOP 구현 - 어드바이스 추가
트랜잭션 기능은 보통 다음과 같이 동작한다.
- 핵심 로직 실행 직전에 트랜잭션을 시작
- 핵심 로직 실행
- 핵심 로직 실행에 문제가 없으면 커밋
- 핵심 로직 실행에 예외가 발생하면 롤백

11. 스프링 AOP 구현 - 포인트 컷 참조
@Aspect
@Order(1)
public static class LogAspect {
	@Around("hello.aop.order.aop.Pointcuts.allOrder()")
	// 어드바이스
	public Object doLog(ProceedingJoinPoint joinPoint) throws Throwable{
		log.info("[log] {}", joinPoint.getSignature()); // join point 시그니처
		return joinPoint.proceed();
	}
}

@Aspect
@Order(2)
public static class TxAspect {
   @Around("hello.aop.order.aop.Pointcuts.orderAndService()")
   public Object doTransaction(ProceedingJoinPoint joinPoint) throws Throwable {
	   try {
		   log.info("[트랜잭션 시작] {}", joinPoint.getSignature());
		   Object result = joinPoint.proceed();
		   log.info("[트랜잭션 커밋] {}", joinPoint.getSignature());
		   return result;
	   } catch (Exception e) {
		   log.info("[트랜잭션 롤백] {}", joinPoint.getSignature());
		   throw e;
	   } finally {
		   log.info("[리소스 릴리즈] {}", joinPoint.getSignature());
	   }
   }
}

12. 어드바이스 종류
- @Around : 메서드 호출(실행) 전후에 수행, 가장 강력한 어드바이스, 조인 포인트 실행 여부 선택, 반환 값 변환, 예외 변환 등이 가능
	- 가장 강력한 어드바이스
		- 조인포인트 실행 여부 선택 joinPoint.proceed() 호출 여부 선택
		- 전달 값 반환 : joinPoint.proceed(args[])
		- 반환 값 반환
		- 예외 변환
		- 트랜잭션 처럼 try catch finally 모두 들어가는 구문 처리가능
	- @ProceedingJoinPoint.proceed()를 호출해야 다음 대상이 호출된다. 만약 호출하지 않으면 다음 대상이 호출되지 않는다.
		- proceed()를 여러번 실행 할 수 있음

- @Before : 조인 포인트 실행 이전에 실행
	- @Around 와 다르게 작업 흐름을 변경할 수 없다.
	- 메서드 종료 시 자동으로 다음 타겟이 호출되나 예외가 발생하면 다음타겟이 호출되지 않는다.
- @AfterReturning : 조인 포인트가 정상 완료 후 실행
	- returning 속성에 사용된 이름은 어드바이스 메서드 매게변수 이름과 일치해야한다.
	- returning 절에 지정된 타입 값을 반환하는 메서드만 대상으로 실행한다.(부모타입을 지정하면 모든 자식타입은 인정된다. 그래서 Object로 지정)
	- @Around와 다르게 반환되는 객체를 변경할 수 없다. (변경하려면 @Around 사용)
- @AfterThrowing : 메서드가 예외를 던지는 경우 실행
	- throwing 속성에 사용된 이름은 어드바이스 메서드 매게변수 이름과 일치해야한다.
	- throwing 절에 지정된 타입 값을 반환하는 메서드만 대상으로 실행한다.(부모타입을 지정하면 모든 자식타입은 인정된다. 그래서 Object로 지정)
- @After : 조인 포인트가 정상 또는 예외에 관계없이 실행(finally)
	- 정상 및 예외 반환 조건 모두 반환
	- 일반적으로 리소스 및 유사한 목적을 해제하는데 사용

모든 어드바이스는 JoinPoint를 첫번째 파라미터에 사용할 수 있다.(생략가능)
단, @Around는 ProceedingJoinPoint를 사용해야 한다.

13. JoinPoint 인터페이스 주요기능
- getArgs :  메서드 인수를 반환
- getThis : 프록시 객체를 반환
- getTarget() : 대상 객체를 반환
- getSignature() : 조인되는 메서드에 대한 설명을 반환
- toString() : 조인되는 방법에 대한 유용한 설명 인쇄

14. ProceedingJoinPoint 인터페이스의 주요 기능
- proceed() : 다음 어드바이스나 타겟을 호출

15. 순서
- @Aspect안에서 동일한 조인포인트이 우선순위를 정했다
- @Around -> @Before -> @After -> @AfterReturning -> @AfterThrowing
- 물론 @Aspect 안에 동일한 종류의 어드바이스가 2개 있으면 순서가 보장되지 않는다. 앞서 배운 것 처럼 @Aspect를 분리하고 @Order를 적용하자.

16. @Around 외에 다른 어드바이스가 존재하는 이유
@Around가 가장 넓은 기능을 제공하는 것은 맞지만, 실수할 가능성이있다.
반면에 @Before, @After와 같은 어드바이스는 기능은 적지만 실수할 가능성이 낮고 코드도 단순하다.
그리고 가장 핵심은 이 코드를 작성한 의도가 명확하게 드러난다.
"좋은 설계는 제약이 있는 것이다" - 제약을 통해 기능을 한정 시키고 에러를 발생할 범위를 줄인다. 제약 덕분에 역할이 분명해진다.

17. 포인트컷 지시자
포인트컷 표현식은 Executio같은 포인트컷 지시자(Pointcut Designator)로 시작한다. 줄여서 PCD라 한다.
- Execution : 메소드 실행 조인 포인트를 매칭한다. 스프링 AOP에서 가장 많이 사용하고, 기능도 복잡하다.
- within : 특정 타입 내의 조인 포인트를 매칭
	- execution에서 타입 부분만 사용한다고 보면됨
	- 주의 할점은 표현식에 부모 타입을 지정하면 안된다. (execution은 가능)
- args : 인자가 주어진 타입의 인스턴스 조인 포인트
	- 기본문법은 execution args 부분과 같다
	- 차이점은 args는 부모타임을 허용한다. args는 실제 넘어온 파라미터 객체 인스턴스를 보고 판단한다.
	- execution은 파라미터 타입이 정확하게 매칭되어야 한다. execution은 클래스에 선언된 정보를 기반으로 판단한다.
	- 파라미터 바인딩에서 주로 사용된다.
- this : 스프링 빈 객체(스프링 AOP 프록시)를 대상으로 하는 조인 포인트
	- * 같은 패턴을 사용할 수 없다.
	- 부모 타입을 허용한다.
- target : target객체(스프링 AOP 프록시가 가르키는 실제 대상)를 대상으로 하는 조인 포인트
	- * 같은 패턴을 사용할 수 없다.
	- 부모 타입을 허용한다.
- @target : 실행 겍체의 클래스에 주어진 타입의 어노테이션이 있는 조인 포인트
	- 인스턴스의 모든 메서드를 조인 포인트로 적용
	- 부모 클래스의 메서드까지 어드바이스를 다 적용
- @within : 주어진 어노테이션이 있는 타입 내 조인 포인트
	- 해당 타입 내에 있는 메서드만 조인 포인트로 적용
	- 자기 자신의 클래스에 정의된 메서드에만 어드바이스를 적용
- @annotation : 메서드가 주어진 어노테이션을 가지고 있는 조인 포인트를 매칭
- @args : 전달된 실제 인수의 런타임 타입에 주어진 타입의 어노테이션을 갖는 조인 포인트
- bean : 스프링 전용 포인트컷 지시자, 빈의 이름으로 포인트컷을 지정

18. execution 문법
execution(접근제어자? 반환타입 선언타입?메서드 이름(파라미터) 예외?)
pointcut.setExpression("execution(public String hello.aop.member.MemberServiceImpl.hello(String))");
- 메소드 실행 조인 포인트를 매칭한다.
- '?'는 생략할 수 있다.
- '*'같은 패턴을 지정할 수 있다.

패키지에서 '.', '..' 의차이를 이해해야 한다.
- '.' : 정확하게 해당 위치의 패키지
- '..' : 해당 위치의 패키지와 그 하위 패키지도 포함

- 부모타입에 있는 메서드만 타입 매칭이 된다.
	- 즉 부모 타입을 표현식에 선언한 경우 부모 타입에서 선언한 메서드가 자식 타입에 있어야 매칭에 성공한다. 그래서 부모 타입에 있는 hello(String)메서드는
	매칭에 성공하지만, 부모 타입에 없는 internal(String)은 매칭에 실패한다. 
	
19. 매개변수 전달
다음은 포인트컷 표현식을 사용해서 어드바이스에 매개변수를 전달할 수 있다.
- this, target, args, @target, @within, @annotation, @args
@Before("allMember() && args(arg..)")
public void logArgs3(String arg) {
	log.info("[logArgs3] arg={}", arg);
}
- 포인트컷의 이름과 매개변수의 이름을 맞추어야 한다. 여기서는 arg로 맞추었다.
- 추가로 타입이 메서드에 지정한 타입으로 제한된다. 여기서는 메서드 타입이 String으로 되어있기 때문에 args(arg,...) ->args(String,...)으로 이해

20. 프록시 방식의 AOP의 한계
스프링은 프록시 방식의 aop를 사용한다. 프록시 방식의 aop는 메서드 내부 호출에 프록시를 적용할 수 없다. 
	- 자기 자신 의존관계 주입
		CallService.internal();
	- 지연 조회
		ObjectProvider;를 사용해서 지연조회
	- 구조 변경
		스프링도 이방법 권장하고 영한씨도 이방법을 씀
		- 내부호출이 아닌 클래스를 분리해서 호출하도록 구조를 변경한다.
		internalService.internal();
	- 클라이언트 다음과 같이 둘다 호출하게 클라이언트에서 변경
		external 호출()
		internal 호출()

* 참고 *
AOP는 public 메서드에만 적용한다. private 메서드 처럼 작은 단위에는 aop를 적용하지 않는다. (주로 트랜잭션 적용이나 주요 컴포넌트 로그 출력기능에 사용)
위의 문제는 실무에서 한번 만나는 문제이다.

21. JDK 동적 프록시 한계
인터페이스를 기반으로 프록시를 생성하는 JDK 동적프록시는 구체 클래스로 타입 캐스팅 불가한 한계가 있다.
	- 구현 클래스로 캐스팅 시도 실패하여 에러난다.
"정리"
JDK 동적 프록시는 대상 객체인 MemberServiceImpl로 캐스팅할 수 없다.
CGLIB프록시는 대상 객체인 MemberServiceImpl로 캐스팅 할 수 있다.

22. CGLIB 한계
- 대상 클래스에 기본 생성자 필수
- 생성자 2번 호출
- final 키워드 클래스, 메소드 사용불가

23. 스프링의 해결책, 생성자 2번호출
	- CGLIB 기본 생성자 필수 문제 해결 스프링 4.0
	- objenesis 라이브러리 사용



   

