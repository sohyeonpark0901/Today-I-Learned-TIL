1. 로그 추적기
애플리케이션이 커지면서 점점 모니터링과 운영이 중요해지는 단계이다. 특히 최근 자주 병목이 발생하고 있다.
어떤 부분에서 병목이 발생하는지, 그리고 어떤 부분에서 예외가 발생하는지를 로그를 통해 확인하는 것이 점점 중요해지고 있다.

* 참고 *
트랜잭션 ID : 하나의 HTTP 요청이 시작해서 끝날 때 까지를 하나의 트랜잭션이라 함

2. 필드 동기화 
로그 추적기를 만들면서 다음 로그를 출력할 때 '트랜잭션ID'와 'level'을 동기화 하는 문제가 있었다.
이 문제를 해결하기 위해 TraceId를 파라미터로 넘기도록 구현했다.
이렇게 해서 동기화는 성공했지만, 로그를 출력하는 모든 메서드에 TraceId 파라미터를 추가해야 하는 문제가 발생했다.
TraceId를 파라미터로 넘기지 않고 이 문제를 해결할 수 있는 방법은 없을까? - 필드 동기화

3. 동시성 문제
결과적으로 Thread A 입장에서는 저장한 데이터와 조회한 데이터가 다른 문제가 발생한다. 이처럼 여러 쓰레드가 동시에 같은 인스턴스 필드 값을 변경하면서
발생하는 문제를 동시성 문제라 한다. 이런 동시성 문제는 여러 쓰레드가 같은 인스턴스의 필드에 접근해야 하디 때문에 트래픽이 적은 상황에서는 확율상 잘 나타나지 않고,
트래픽이 점점 많아질수록 자주 발생한다. 특히 스프링 빈 처럼 싱글톤 객체의 필드를 변경하여 사용할때 이러한 동시성 문제를 조심해야 한다.
* 참고 *
이런 동시성 문제는 지역 변수에서는 발생하지 않는다. 지역 변수는 스레드마다 각각 다른 메모리 영역이 할당된다. 
동시성 문제가 발생하는 곳은 같은 인스턴스의 필드(주로 싱글톤에서 자주 발생), 또는 static 같은 공용 필드에 접근할 때 발생한다.
동시성 문제는 값을 읽기만 하면 발생하지 않는다. 어디선가 값을 변경하기 때문에 발생한다.

그렇다면 지금처럼 싱글톤 객체의 필드를 사용하면서 동시성 문제를 해결하려면 어떻게 해야할까? - ThreadLocal

4. ThreadLocal
ThreadLocal은 해당 스레드만 접근할 수 있는 특별한 저장소를 말한다. 쉽게 이야기해서 물건 보관 창구를 떠올리면 된다. 여러 사람이 같은 물건
보관 창구를 사용하더라도 창구 직원은 사용자를 인식해서 사용자별로 확실하게 물건을 구분해준다.
사용자A, 사용자B 모두 창구 직원을 통해서 물건을 보관하고, 꺼내지만 창구 지원이 사용자에 따라 보관한 물건을 구분해주는 것이다.

- 일반적인 변수 필드
여러 스레드가 같은 인스턴스 필드에 접근하면 처음 스레드가 보관한 데이터가 사라질 수 있다.
threadA가 userA라는 값을 저장하고 threadB가 userB라는 값을 저장하면 직전에 thread-A가 저장한 userA 값은 사라진다.
- ThreadLocal
스레드 로컬을 사용하면 각 스레드마다 별도의 내부 저장소를 제공한다. 따라서 같은 인스턴스의 스레드 로컬 필드에 접근해도 문제 없다.
threadA가 userA라는 값을 저장하면 ThreadLocal은 thread-A 전용 보관소에 데이터를 안전하게 보관한다.
threadB가 userB라는 값을 저장하면 ThreadLocal은 thread-B 전용 보관소에 데이터를 안전하게 보관한다.
ThreadLocal을 통해서 데이터를 조회할 때도 thread-A가 조회하면 ThreadLocal은 thread-A 전용 보관소에서 userA 데이터를 반환해준다.
물론 thread-B가 조회하면 thread-B 전용 보관소에서  userB 데이터를 반환해준다.
자바 언어차원에서 ThreadLocal을 지원하기 위한 java.lang.ThreadLocal 클래스를 제공한다.

5. ThreadLocal 사용법
- 값 저장 : ThreadLocal.set(xxx)
- 값 조회 : ThreadLocal.get()
- 값 제거 : ThreadLocal.remove()

* 주의 *
해당 쓰레드가 로컬을 모두 사용하고 나면 ThreadLocal.remove()를 호출해서 ThreadLocal에 저장된 값을 제거해주어야 한다.

6. ThreadLocal 주의사항
ThreadLocal의 값을 사용 후 제거하지 않고 그냥 두면 WAS(톰켓)처럼 스레드 풀을 사용하는 경우 심각한 문제가 발생할 수 있다.
1. 사용자 HTTP 응답이 끝난다.
2. WAS는 사용이 끝난 thread-A를 스레드 풀에 반환한다. 스레드를 생성하는 비용은 비싸기 때문에 스레드를 제거하지 않고 
보통 스레드 풀을 통해서 스레드를 재사용한다.
3. thread-A는 스레드 풀에 아직 살아있다. 따라서 스레드 로컬의 threadA 전용 보관소에 사용자A 데이터도 함께 살아있게된다.

7. 템플릿 메서드 패턴 시작
지금까지 로그 추적기를 열심히 잘 만들었다. 요구사항도 만족하고, 파라미터를 넘기는 불편함을 제거하기 위해 스레드 로컬도 도입했다.
그런데 로그 추적기를 막상 프로젝트에 도입하려고 하니 개발자들의 반대 목소리가 높다.
로그 추적기 도입 전과 도입 후의 코드를 비교해보자.
V0는 해당 메서드가 실제 처리해야 하는 핵심 기능만 깔끔하게 남아있다. 반면에 V3에는 핵심 기능보다 로그를 출력해야하는 부가 기능이 코드가 훨씬 더 많고 복잡하다.

8. 핵심기능 vs 부가기능
- 핵심기능 : 해당객체가 제공하는 고유의 기능이다. 예를 들어서 orderService의 핵심 기능은 주문 로직이다. 메서드 단위로 보면
orderService.orderItem()의 핵심 기능은 주문 데이터를 저장하기 위해 리포지토리를 호출하는 
orderRepository.save(itemId)코드가 핵심이다.

- 부가기능 : 핵심기능을 보조하기 위해 제공되는 기능이다. 예를 들어서 로그 추적 로직, 트랜잭션 기능이 있다. 이러한 부가 기능은 단독으로 사용되지는 않고,
핵심 기능과 함께 사용된다. 예를 들어서 로그 추적 기능은 어떤 핵심 기능이 호출되었는지 로그를 남기기 위해 사용된다.

controller, service, repository의 코드를 잘보면, 로그 추적기를 사용하는 구조는 모두 동일하다. 중간에 핵심 기능을 사용하는 코드만 다를 뿐이다.
부가 기능과 관련된 코드가 중복이니 중복을 별도의 메서드로 뽑아내면 될것같다. 그런데, try ~ catch 는 물론이고, 핵심 기능 부분이 중간에 있어서
단순하게 메서드로 추출하는 것은 어렵다.

"변하는 것과 변하지 않는 것을 분리"
좋은 설계는 변하는 것과 변하지 않는 것을 분리하는 것이다.
여기서 핵심 기능 부분은 변하고, 로그 추적기를 사용하는 부분은 변하지 않는 부분이다. 이둘을 분리해서 모듈화해야 한다. - 템플릿 메서드 패턴(Template Mehod Pattern)

9. 템플릿 메서드 패턴
이름 그대로 템플릿을 사용하는 방식이다. 템플릿은 기준이 되는 거대한 틀이다. 템플릿이라는 틀에 변하지 않는 부분을 몰아준다. 
그리고 일부 변하는 부분을 별도로 호출해서 해결한다.

abstractTemplate 코드를 보자. 변하지 않는 부분인 시간 측정 로직을 몰아둔 것을 확인할 수 있다. 이제 이것이 하나의 템플릿이 된다.
그리고 템플릿 안에서 변하는 부분은 call() 메서드를 호출해서 처리한다. 템플릿 메서드 패턴은 부모 클래스에 변하지 않는 템플릿 코드를 둔다.
그리고 변하는 부분은 자식 클래스에 두고 상속과 오버라이딩을 사용해서 처리한다.
public class SubClassLogic1 extends AbstractTemplate{
    @Override
    protected void call() {
        log.info("비즈니스 로직1 실행");
    }
}
template().execute()를 호출하면 템플릿 로직인 AbstractTemplate.execute()를 실행한다. 여기서 중간에 call() 메서드를 호출하는데,
이 부분이 오버라이딩 되어있다. 따라서 현재 인스턴스인 SubClassLogic1 인스턴스의 SubClassLogic.call() 메서드가 호출된다.
void templateMethodV1(){
	AbstractTemplate template1 = new SubClassLogic1();
	template1.execute();

	AbstractTemplate template2 = new SubClassLogic2();
	template2.execute();
}

템플릿 메서드 패턴은 이렇게 다형성을 사용해서 변하는 부분과 변하지 않는 부분을 분리하는 방법이다.

10. 템플릿 메서드 패턴 - 익명 내부 클래스 사용하기
템플릿 메서드 패턴은 SubClassLogic1, SubClassLogic2 처럼 클래스를 계속 만들어야하는 단점이 있다. 익명내부 클래스를 사용하면 이런 단점을 보완할 수 있다.
익명 내부 클래스를 사용하면 객체 인스턴스를 생성하면서 동시에 생성할 클래스를 상속 받은 자식 클래스를 정의할 수 있다.
이클래스는 SubClassLogic1처럼 직접 지정하는 이름이 없고 클래스 내부에 선언되는 클래스여서 익명 내부 클래스라 한다.

템플릿 메서드 패턴 덕분에 변하는 코드와 변하지 않는 코드를 명확하게 분리했다.
로그를 출력하는 템플릿 역할을 하는 변하지 않는 코드는 모두 AbstractTemplate에 담아두고, 변하는 코드는 자식 클래스를 만들어서 분리했다.

11. 좋은 설계란?
좋은 설계라는 것은 무엇일까? 바로 변경이 일어날 때 자연스럽게 드러난다.
지금까지 로그를 남기는 부분을 모아서 하나로 모듈화하고, 비즈니스 로직 부분을 분리했다. 여기서 만약 로그를 남기는 로직을 변경해야 한다고 생각해보자.
AbstractTemplate 코드를 변경해야 한다. 단순히 AbstractTemplate 코드만 변경하면 된다.

"단일 책임 원칙(SRP)"
V4는 단순히 템플릿 메서드 패턴을 적용해서 소스코드 몇줄을 줄인 것이 전부가 아니다.
로그를 남기는 부분에 단일 책임 원칙(SRP)을 지킨 것이다. 변경 지점을 하나로 모아서 변경에 쉽게 대처할 수 있는 구조를 만든 것이다.

12. 템플릿 메서드 패턴 - 정의
GOF 디자인 패턴에서는 템플릿 메서드 패턴을 다음과 같이 정의했다.
"작업에서 알고리즘의 골격을 정의하고 일부 단계를 하위 클래스로 연기합니다. 템플릿 메서드를 사용하면 하위 클래스가 알고리즘의 구조를 변경하지 않고도 
알고리즘의 특정 단계를 재정의 할 수 있습니다."

하지만!
템플릿 메서드 패턴은 상속을 사용한다. 따라서 상속에서 오는 단점을 그대로 안고간다. 특히 자식 클래스가 부모 클래스와 컴파일 시점에 강하게 결합되는 문제가 있다.
이것은 의존관계에 대한 문제이다. 자식 클래스 입장에서는 부모 클래스 기능을 전혀 사용하지 않는다.
자식클래스를 작성할 때 부모 클래스의 기능을 사용한 것이 있었던가?
그럼에도 불구하고 템플릿 메서드 패턴을 위해 자식 클래스는 부모 클래스를 상속 받고 있다.
자식 클래스의 Extends 다음에 바로 부모 클래스가 코드상에 지정되어있다. 따라서 부모 클래스 기능을 사용하든 사용하지 않든 간에 부모 클래스를 강하게 의존하게 된다.
여기서 강하게 의존한다는 뜻은 자식 클래스의 코드에 부모 클래스의 코드가 명확하게 적혀 있다는 뜻이다.
이것은 좋은 설계가 아니다. 그리고 이런 잘못된 의존관계 때문에 부모 클래스를 수정하면, 자식 클래스에도 영향을 줄 수 있다.

템플릿 메서드 패턴과 비슷한 역할을 하면서 상속의 단점을 제거할 수 있는 디자인 패턴 - 전략 패턴 (Strategy Pattern)

13. 전략 패턴 - 정의
템플릿 메서드 패턴은 부모 클래스에 변하지 않는 템플릿을 두고, 변하는 부분을 자식 클래스에 두어 상속을 사용해서 문제를 해결했다.
전략 패턴은 변하지 않는 부분을 Context라는 곳에 두고, 변하는 부분을 Strategy라는 인터페이스를 만들고 해당 인터페이스를 구현하도록 해서 문제를 해결한다.
상속이 아니라 위임으로 문제를 해결하는 것이다. 전략 패턴에서 Context는 변하지 않는 템플릿 역할을 하고 Strategy는 변하는 알고리즘 역할을 한다.

GOF 디자인 패턴에서 정의한 전략 패턴 의도는 다음과 같다
"알고리즘 제품군을 정의하고 각각을 캡슐화하여 상호 교환 가능하게 만들자. 전략을 사용하면 알고리즘을 사용하는 클라이언트와 독립적으로 알고리즘을 변경할 수 있다."

14. 전략 패턴 - 예제
public class ContextV1 {
    private Strategy strategy;

    public ContextV1(Strategy strategy) {
        this.strategy = strategy;
    }

    public void execute(){
        long startTime = System.currentTimeMillis();
        // 비즈니스 로직 실행 - 위임
        strategy.call();

        // 비즈니스 로직 종료
        long endTime = System.currentTimeMillis();
        long resultTime = endTime - startTime;
        log.info("resultTime = {}", resultTime);
    }
}

ContextV1은 변하지 않는 로직을 가지고 있는 템플릿 역할을 하는 코드이다. 전략 패턴에서는 이것을 컨택스트(문맥)이라 한다.
쉽게 이야기해서 컨택스트(문맥)는 크게 변하지 않지만, 그 문맥 속에서 strategy를 통해 일부 전략이 변경된다 생각하면 된다.
Context 내부에 Strategy strategy 필트를 가지고 있다. 이 필드에 변하는 부분인 Strategy의 구현체를 주입하게 된다.
전략 패턴의 핵심은 Context는 Strategy 인터페이스만 의존한다는 점이다. Strategy 구현체를 변경하거나 새로 만들어도 Context 코드에는 영향을 주지 않는다.

어디서 많이 본 코드 같지 않은가? 바로 스프링에서 의존관계 주입에서 사용하는 방식이 바로 전략 패턴이다.

@Test
void strategyV1(){
	StrategyLogic1 strategyLogic1 = new StrategyLogic1();
	ContextV1 contextV1 = new ContextV1(strategyLogic1);
	contextV1.execute();

	StrategyLogic2 strategyLogic2 = new StrategyLogic2();
	ContextV1 contextV2 = new ContextV1(strategyLogic2);
	contextV2.execute();
}
전략 패턴을 사용해보자. 코드를 보면 의존관계를 주입을 통해 ContextV1에 Strategy의 구현체인 strategyLogic1를 주입하는 것을 확인할 수 있다.
이렇게해서 Context안에 원하는 전략을 주입한다. 이렇게 원하는 모양으로 조립을 완료하고 난 다음에 context1.execute()를 호출해서 context를 실행한다.

* 로직 순서 *
1. Context에 원하는 Strategy 구현체를 주입한다.
2. 클라이언트는 Context를 실행한다.
3. Context는 context로직을 시작한다.
4. Context 로직 중간에 strategy.call()을 호출해서 주입 받은 Strategy 로직을 실행한다.
5. Context는 나머지 로직을 실행한다.

15. ContextV1 - 추가
익명 내부 클래스를 자바8부터 제공하는 람다로 변경할 수 있다. 람다로 변경하려면 인터페이스에 메서드가 1개만 있으면 되는데,
여기에서 제공하는 Strategy 인터페이스는 메서드가 1개만 있으므로 람다를 사용할 수 있다.

16. 선조립 후실행
여기서 이야기하고 싶은 부분은 Context의 내부 필드에 Strategy를 두고 사용하는 부분이다.
이 방식은 Context와 Strategy를 실행 전에 원하는 모양으로 조립해두고, 그 다음에 Context를 실행하는 선 조립, 후 실행하는 방식에서 매우 유용하다.

Context와 Strategy를 한번 조립하고 나면 이후로는 Context를 실행하기만 하면된다. 우리가 스프링으로 애플리케이션을 개발할 때 애플리케이션을 로딩 시점에
의존관계 주입을 통해 모두 맺어두고 난 다음에 실제 요청을 처맇라는 것과 같은 원리이다.

하지만!
이 방식의 단점은 Context와 Strategy를 조립한 이후에는 전략을 변경하기가 번거롭다는 점이다. 물론 Context에 setter를 제공해서 Strategy를 넘겨 받아
변경하면 되지만, Context를 싱글톤으로 사용할 때는 동시성 이슈 등 고려할 점이 많다. 그래서 전략을 실시간으로 변경해야 하면 차라리 이전에 개발한 테스트 코드처럼
Context를 하나 더 생성하고 그곳에 다른 Strategy를 주입하는 것이 더 나은 선택일 수 있다.

17. 템플릿 콜백 패턴
ContextV2는 변하지 않는 템플릿 역할을 한다. 그리고 변하는 부분은 파라미터로 넘어온 Strategy의 코드를 실행해서 처리한다. 이렇게 다른코드의
인수로 넘겨주는 실행 가능한 코드를 콜백이라한다.

* 콜백 정의 *
프로그래밍에서 콜백(callback)또는 콜애프터 함수(call-after function)는 다른 코드의 인수로서 넘겨주는 실행 가능한 코드를 말한다.
콜백을 넘겨받는 코드는 이 콜백을 필요할 때 마다 즉시 실행할 수도 있고, 아니면 나중에 실행할 수도 있다.

18. 자바 언어에서 콜백
- 자바 언어에서 실행 가능한 코드를 인수로 넘기려면 객체가 필요하다. 자바8부터는 람다를 사용할 수 있다.
- 자바 8 이전에는 보통 하나의 메소드를 가진 인터페이스를 구현하고, 주로 익명 내부 클래스를 사용했다.
- 최근에는 주로 람다를 사용한다.

19. 템플릿 콜백 패턴
- 스프링에서는 ContextV2와 같은 방식의 전략 패턴을 템플릿 콜백 패턴이라 한다. 전략 패턴에서 Context가 템플릿 역할을 하고,
Strategy부분이 콜백으로 넘어온다 생각하면된다.
- 참고로 템플릿 콜백 패턴은 GOF 패턴은 아니고, 스프링 내부에서 이런 방식을 자주 사용하기 때문에, 스프링 안에서만 이렇게 부른다.
전략패턴에서 템플릿과 콜백 부분이 강조된 패턴이라 생각하면된다.
- 스프링에서는 JdbcTemplate, RestTemplate, TransactionTemplate, RedisTemplate처럼 다양한 템플릿 콜백 패턴이 사용된다.
스프링에서 이름에 XxxTemplate이 있다면 템플릿 콜백 패턴으로 만들어졌다 생각하면된다.

그런데 지금까지 위의 방식의 한계는 아무리 최적화를 해도 결국 로그 추적기를 적용하기 위해서 원본 코드를 수정해야 한다는 점이다.
클래스가 수백개이면 수백개를 더 힘들게 수정하는가 조금 덜 힘들게 수정하는가의 차이가 있을 뿐, 본질적으로 코드를 다 수정해야 하는것은 마찬가지이다.

20. @RequestMapping
스프링 MVC는 @Controller또는 @RequestMapping 애노테이션이 타입이 있어야 스프링 컨트롤러로 인식한다.
그리고 스프링 컨트롤러로 인식해야, Http URL로 매핑되고 동작한다. 이 어노테이션은 인터페이스에 사용해도 된다.

21. @ResponseBody
Http메세지에 컨버터를 사용해서 응답한다. 이 어노테이션은 인터페이스에 사용해도 된다.

22. @SpringBootApplication(scanBasePackages = "hello.proxy.app")
@ComponentScan의 기능과 같다. 컴포넌트 스캔을 시작할 위치를 지정한다. 이 값을 설정하면 해당 패키지와 그 하위 패키지를 컴포넌트 스캔한다.
이 값을 사용하지 않으면 ProxyApplication이 있는 패키지와 그 하위 패키지를 스캔한다.

